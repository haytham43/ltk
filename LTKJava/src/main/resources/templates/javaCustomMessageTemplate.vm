## javaCustomMessageTemplate.vm
package org.llrp.ltk.generated.custom.messages;
	
/*
 *
 * This file was generated by LLRP Code Generator 
 * see http://llrp-toolkit.cvs.sourceforge.net/llrp-toolkit/ for more information
 * Generated on: $utility.getDateNTime(); 
 *
 */

/*
 * Copyright 2007 ETH Zurich
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 *
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  
 * See the License for the specific language governing permissions and limitations under the License.
 *
 */
	
## some strings we need
#set($encode = ".encodeBinary()")	
#set($list = "List")
#set($length = ".length()")
#set($resName = "reserved")
#set($resType = "BitList")
#set($typeNum = ".TYPENUM")
#set($add = ".add")
#set($emptyBrack = "()")

##set the class names here
#set ($parameterReference = "ParameterReference")
#set ($choiceReference = "ChoiceReference")
#set ($messageDefinition = "ParameterDefinition")
#set ($choiceDefinition = "ChoiceDefinition")
#set ($reservedDefinition = "ReservedDefinition")
#set ($fieldDefinition = "FieldDefinition")
#set ($listRepeat = "1-N")
#set ($singleRepeat = "1")
#set ($optionalRepeat = "0-1")
#set ($optionalList = "0-N")
	
	
	
##imports
## must clear the helper set
$utility.clearImports()
## some imports are always needed
## remember imports to avoid importing twice the same

	import java.util.LinkedList;
	$utility.addImport("LinkedList")
	import java.util.List;
	$utility.addImport("List")
	
	import org.apache.log4j.Logger;
	$utility.addImport("logging")
	
	import org.jdom.Document;
	$utility.addImport("Document")

	import org.llrp.ltk.types.LLRPBitList;
	$utility.addImport("LLRPBitList")	
	import org.llrp.ltk.types.LLRPMessage;
	$utility.addImport("LLRPMessage")
	import org.llrp.ltk.types.UTF8String;
	$utility.addImport("UTF8String")
	import org.llrp.ltk.types.SignedShort;
	$utility.addImport("SignedShort")
	import org.llrp.ltk.types.BitList;
	$utility.addImport("BitList")
	import org.llrp.ltk.types.UnsignedInteger;
	$utility.addImport("UnsignedInteger")
	import org.llrp.ltk.types.UnsignedShort;
	$utility.addImport("UnsignedShort")
	import org.llrp.ltk.types.UnsignedByte;
	$utility.addImport("UnsignedByte")
	import org.llrp.ltk.exceptions.LLRPException;
	$utility.addImport("LLRPException")
	import org.llrp.ltk.exceptions.IllegalBitListException;
	$utility.addImport("IllegalBitListException")
	
	## field or reserved
	#foreach($field in $message.getFieldOrReserved())
		## reserved field
		#if ($utility.hasType($field,$reservedDefinition))
			#if (!$utility.hasImport($resType))
				import org.llrp.ltk.types.$resType;
				$utility.addImport($resType)
			#end
		#elseif ($utility.hasType($field,$fieldDefinition))
			## its a field and therefore it might be also an enumeration
			## only place where we can find super types of enumerations
			## distinguish between custom and normal enumerations
			#if ($field.getEnumeration() && !$utility.hasImport($field.getEnumeration()) && !$utility.isCustomEnumeration($field.getEnumeration()))
				import org.llrp.ltk.generated.enumerations.$field.getEnumeration();
				$utility.setSuperType($field.getEnumeration(),$field.getType().value())
				$utility.addImport($field.getEnumeration())
			#elseif ($field.getEnumeration() && !$utility.hasImport($field.getEnumeration()) && $utility.isCustomEnumeration($field.getEnumeration()))
				#set($custEnum = $utility.firstToUpperCase($field.getEnumeration()))
				import org.llrp.ltk.generated.custom.enumerations.$custEnum;
				$utility.setSuperType($field.getCustomEnumeration(),$field.getType().value())
				$utility.addImport($field.getCustomEnumeration())
			#elseif (!$utility.hasImport($utility.convertType($field.getType().value())))
				import org.llrp.ltk.types.$utility.convertType($field.getType().value());
				$utility.addImport($utility.convertType($field.getType().value()))
			#end
		## FieldDefinition
		#else
					//TODO template wrote this - unexpected object $field
		#end	
	#end
	
	
	## parameter or choice
	#foreach($field in $message.getParameterOrChoice())
		##for choices we must also import implementing classes
		#if ($utility.hasType($field,$choiceReference))
			##check all subtypes
			#foreach ($subtype in $utility.getSubTypes($field.getType()))
				#if (!$utility.hasImport($subtype) && $utility.isCustomParameter($subtype))
					import org.llrp.ltk.generated.custom.parameters.$subtype;
					$utility.addImport($subtype)
				#elseif (!$utility.hasImport($subtype) && !$utility.isCustomParameter($subtype))
					import org.llrp.ltk.generated.parameters.$subtype;
					$utility.addImport($subtype)
				#end
			#end
			#if ($utility.isCustomChoice($field.getType()))
				import org.llrp.ltk.generated.custom.interfaces.$field.getType();
				$utility.addImport($field.getType())
			#else 
				import org.llrp.ltk.generated.interfaces.$field.getType();
				$utility.addImport($field.getType())
			#end
		#else
			#if (!$utility.hasImport($field.getType()) && $utility.isCustomParameter($field.getType()))
				import org.llrp.ltk.generated.custom.parameters.$field.getType();
				$utility.addImport($field.getType())
			#elseif (!$utility.hasImport($field.getType()) && !$utility.isCustomParameter($field.getType()))
				import org.llrp.ltk.generated.parameters.$field.getType();
				$utility.addImport($field.getType())
			#end
		#end
	#end
	
	##import interfaces to implement
	#foreach ($interface in $utility.getInterfaces($message.getName()))

			#if ($utility.isCustomChoice($interface))
				import org.llrp.ltk.generated.custom.interfaces.$interface;
				$utility.addImport($interface)
			#else 
				import org.llrp.ltk.generated.interfaces.$interface;
				$utility.addImport($interface)
			#end
	#end
##end imports

	
	
		
/**
 * $message.getAnnotation().get(0).getChildNodes().item(0).item(0).getNodeValue();
 */




## beginning of class
public class $message.getName() extends LLRPMessage{						

##typeNum is always needed
	public static final UTF8String vendor = new UTF8String("$message.getVendor()");
	public static final UnsignedByte subtype = new UnsignedByte((new Integer($message.getSubtype())).byteValue());
	private static final Logger logging = Logger.getLogger("$custom.getName()");
	#if ($custom.getResponseType())
		public static final String RESPONSETYPE = "$custom.getResponseType()";
	#else 
		public static final String RESPONSETYPE = "";
	#end
## field or reserved
#foreach($field in $message.getFieldOrReserved())
	## reserved field
	#if ($utility.hasType($field,$reservedDefinition))
		private $resType $resName$utility.getCurrentNumerOfReserved() = new $resType ($field.getBitCount());
	#elseif ($utility.hasType($field,$fieldDefinition))
		private $utility.convertType($field.getType().value()) $utility.firstToLowerCase($field.getName());
	## FieldDefinition
	#else
				//TODO template wrote this - unexpected object $field
	#end	
#end

##must clear numbers of reserved definitons found
$utility.clearNumberOfReserved()


## constructor
	public $message.getName()(){
	}


	public $message.getName()(LLRPBitList list){
		decodeBinary(list.toByteArray());
	}

	public $message.getName()(byte[] byteArray){
		decodeBinary(byteArray);
	}
		

	
## parameter or choice
#foreach($field in $message.getParameterOrChoice())
	## parameters usually don't have names, so the variable gets the typ with first letter to lower case as name
	## however there are some exceptions to this where there is a name given

	#if ($field.getName())
		#set ($curName = $utility.firstToLowerCase($field.getName()))
	#else
		#set ($curName = $utility.firstToLowerCase($field.getType()))
	#end 	
	#if ($field.getRepeat()== $listRepeat  || $field.getRepeat()== $optionalList)
		private List<$field.getType()> $curName$list = new LinkedList<$field.getType()>();
	#else
		private $field.getType() $curName;
	#end
#end



## encode method
	public LLRPBitList encodeBinarySpecific(){
	LLRPBitList resultBits = new LLRPBitList();
	
	//vendor and type encoded first
	resultBits.append(vendor.encodeBinary());
	resultBits.append(subtype.encodeBinary());
	## field or reserved
	#foreach($field in $message.getFieldOrReserved())
		#if ($utility.hasType($field,$reservedDefinition))
			resultBits.append($resName$utility.getCurrentNumerOfReserved()$encode);
		#elseif ($utility.hasType($field,$fieldDefinition))
			resultBits.append($utility.firstToLowerCase($field.getName())$encode);
		## FieldDefinition
		#else
			//TODO template parameter encode wrote this - unexpected object $field
		#end
	#end
	## parameter or choice
	#foreach($field in $message.getParameterOrChoice())
		## parameters usually don't have names, so the variable gets the type with first letter to lower case as name
		## however there are some exceptions to this where there is a name given

		#if ($field.getName())
			#set ($curName = $field.getName())
		#else
			#set ($curName = $utility.firstToLowerCase($field.getType()))
		#end
		## check if it is a list 	
		#if ($field.getRepeat()==$listRepeat  || $field.getRepeat()== $optionalList)
			for ($field.Type field : $curName$list){
				resultBits.append(field$encode);
			}
		#else
			resultBits.append($curName$encode);
		#end
	#end
		return resultBits;
	}
##must clear numbers of reserved definitons found
$utility.clearNumberOfReserved()



##decode
  
  	@Override
	public void decodeBinarySpecific(LLRPBitList binary){
		int position = 0;
		int tempByteLength;
		int tempLength = 0;
		int count;
		int fieldCount;
		SignedShort type;
		

		Short messageType = new SignedShort(binary.subList(RESERVEDLENGTH, 10)).toShort();

		// skip first three bits as they are reserved
		position=3;
		version = new BitList(3);
		// version is a BitList of length 3
		for (int i =0;i<3;i++){
			// read bits starting at 3 (position==3)
			if (binary.get(position+i)){
				version.set(i);
			} else {
				version.clear(i);
			}
		}
		//skip message type - length starts at position 16
		position =RESERVEDLENGTH+TYPENUMBERLENGTH;
		messageLength = new UnsignedInteger(binary.subList(position, UnsignedInteger.length()));
		position+=UnsignedInteger.length();
		messageID = new UnsignedInteger(binary.subList(position, UnsignedInteger.length()));
		position+=UnsignedInteger.length();
		//call decodeSpecific which is implemented by the class subtyping this one. 
		// pass only data bits, not header
		
		// vendor and message subtype must not be decoded, they are already given by class
		//jump over vendor and subtype
		position+=40;
		
		
		
		
		
		
		
		## field or reserved
		#foreach($field in $message.getFieldOrReserved())
			## reserved field
			#if ($utility.hasType($field,$reservedDefinition))
				##reserved, do nothing
			#elseif ($utility.hasType($field,$fieldDefinition))
				#set ($curName = $utility.firstToLowerCase($field.getName()))
				#set ($curType = $utility.convertType($field.getType().value()))
				#if ($utility.isArray($curType))
					// array. first 16 bits indicate length of array
					fieldCount = new UnsignedShort(binary.subList(position, UnsignedShort.length())).toShort();			
					tempLength=$curType$length*fieldCount+UnsignedShort.length();
					$curName = new $curType (binary.subList(position, tempLength));
					position += tempLength;
				#elseif ($utility.isByteToEnd($curType))
					$curName = new $curType (binary.subList(position, binary.length()-position));
					position += binary.length()-position;
				#else
					$curName = new $curType (binary.subList(position, $curType$length));
					position += $curType$length;
				#end
			#else
						//TODO template wrote this - unexpected object $field
			#end
		#end  
		
		
		## parameter or choice
		#foreach($field in $message.getParameterOrChoice())
		## get name first, not all have a name attribute
		#if ($field.getName())
			#set ($curName = $field.getName())
		#else
			#set ($curName = $utility.firstToLowerCase($field.getType()))
		#end
		
		## check if it is a list 	
		#if ($field.getRepeat()==$listRepeat  || $field.getRepeat()== $optionalList)
			$curName$list = new LinkedList<$field.getType()>();
			while (position < binary.length()){
				// look ahead to see type
				type = new SignedShort(binary.subList(position+RESERVEDLENGTH, TYPENUMBERLENGTH));
				tempByteLength = new UnsignedShort(binary.subList(position+TYPENUMBERLENGTH+RESERVEDLENGTH, UnsignedShort.length())).toShort();			
				tempLength=8*tempByteLength;
				##distinguish between choices and parameters. For choices, we must find the actual types
				#if ($utility.hasType($field,$choiceReference))
					//choiceRef
					##check all subtypes
					#foreach ($subtype in $utility.getSubTypes($field.getType()))
						if (type.equals($subtype$typeNum)){
							$curName$list$add (new $subtype (binary.subList(position,tempLength)));
							position+=tempLength;
							continue;
						}
					#end
					//if no parameter matched, jump out of while loop
					break;
				#elseif ($utility.hasType($field,$parameterReference))
					//paramRef
					$curName$list$add (new $field.getType() (binary.subList(position,tempLength)));
					position+=tempLength;		
				#else
					//TODO template wrote this in decode > list- unexpected object $field in while
				#end
			}
			


		#elseif ($field.getRepeat()==$singleRepeat || $field.getRepeat()==$optionalRepeat)
			##may be optional or exactly once
			// look ahead to see type
			// may be optional or exactly once
				if (binary.get(position)){
					// do not take the first bit as it is always 1
        			type = new SignedShort(binary.subList(position+1, 7));
				} else {
					type = new SignedShort(binary.subList(position+RESERVEDLENGTH, TYPENUMBERLENGTH));
					tempByteLength = new UnsignedShort(binary.subList(position+RESERVEDLENGTH+ TYPENUMBERLENGTH, UnsignedShort.length())).toShort();			
					tempLength=8*tempByteLength;
				}
			tempByteLength = new UnsignedShort(binary.subList(position+TYPENUMBERLENGTH+RESERVEDLENGTH, UnsignedShort.length())).toShort();			
			tempLength=8*tempByteLength;
			##distinguish between choices and parameters. For choices, we must find the actual types
			#if ($utility.hasType($field,$choiceReference))
				##check all subtypes
				#foreach ($subtype in $utility.getSubTypes($field.getType()))
					//if first bit is 1 it is a TV Parameter
					if (binary.get(position)){
						// length can statically be determined for TV Parameters
        				tempLength = $subtype$length;
					} 
					if (typeNum.equals($subtype$typeNum)){
						$curName = new $subtype (binary.subList(position,tempLength));
					}
					position += tempLength;
				#end
			
			#elseif ($utility.hasType($field,$parameterReference))
				if (binary.get(position)){
					// length can statically be determined for TV Parameters
        			tempLength = $curName$length;
				} 
				if(type.equals($field.getType()$typeNum)){
					$curName = new $field.getType() (binary.subList(position,tempLength));	
					position+=tempLength;
				} else {
				## if it is an optional parameter it is ok to come to here. Therefor only print an error message if it is not optional
					#if ($field.getRepeat()==$singleRepeat )
						// its an error - parameter must be here
						throw new IllegalBitListException("parameter expected: $field.getType() but recieved " + type );
					#else
						logging.info("parameter "+$curName +" not set");
					#end
				}	
			#else
				//TODO template wrote this - unexpected object $field
			#end
		#else
			// TODO repeat is $field.getRepeat() but this is not yet implemented
		#end
	#end
  	}
  	
	@Override
	public void decodeXML(Document xml) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public Document encodeXML() {
		// TODO Auto-generated method stub
		return null;
	}
  	
  	
## generate getters 
	//getters
	## field or reserved
	#foreach($field in $message.getFieldOrReserved())
		## reserved field
		#if ($utility.hasType($field,$reservedDefinition))
			## nothing
		#elseif ($utility.hasType($field,$fieldDefinition))
			public $utility.convertType($field.getType().value()) get$field.getName()$emptyBrack{
				return $utility.firstToLowerCase($field.getName());
			}
		## FieldDefinition
		#else
					//TODO template wrote this - unexpected object $field
		#end	
	#end


	## parameter or choice
	#foreach($field in $message.getParameterOrChoice())
		## parameters usually don't have names, so the variable gets the typ with first letter to lower case as name
		## however there are some exceptions to this where there is a name given
		#if ($field.getName())
			#set ($curName = $field.getName())
		#else
			#set ($curName = $utility.firstToLowerCase($field.getType()))
		#end 
		#if ($field.getRepeat()== $listRepeat  || $field.getRepeat()== $optionalList)
			public List<$field.getType()> get$utility.firstToUpperCase($curName)$list$emptyBrack {
				return $curName$list;
			}
				
		#else
			public $field.getType() get$utility.firstToUpperCase($curName)$emptyBrack  {
				return $curName;
			}
		#end
	#end


	
## generate setters 
	//setters
	## field or reserved
	#foreach($field in $message.getFieldOrReserved())
		## reserved field
		#if ($utility.hasType($field,$reservedDefinition))
			## nothing
		#elseif ($utility.hasType($field,$fieldDefinition))
			public void  set$field.getName() ($utility.convertType($field.getType().value()) $utility.firstToLowerCase($field.getName())){
				this.$utility.firstToLowerCase($field.getName()) = $utility.firstToLowerCase($field.getName());
			}
		## FieldDefinition
		#else
					//TODO template wrote this - unexpected object $field
		#end	
	#end


	## parameter or choice
	#foreach($field in $message.getParameterOrChoice())
		## parameters usually don't have names, so the variable gets the typ with first letter to lower case as name
		## however there are some exceptions to this where there is a name given
		#if ($field.getName())
			#set ($curName = $field.getName())
		#else
			#set ($curName = $utility.firstToLowerCase($field.getType()))
		#end 
		#if ($field.getRepeat()== $listRepeat  || $field.getRepeat()== $optionalList)
			public void set$utility.firstToUpperCase($curName)$list (List<$field.getType()> $curName$list) {
				this.$curName$list = $curName$list;
			}
				
		#else
			public void set$utility.firstToUpperCase($curName) ($field.getType()  $curName)  {
				this. $curName =  $curName;
			}
		#end
	#end


	
	@Override
	public SignedShort getTypeNum() {
		return new SignedShort(1023);
	}
	
## end of Class	
}
